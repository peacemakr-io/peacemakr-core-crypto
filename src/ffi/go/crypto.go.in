//
// Created by Aman LaChapelle on 7/20/18.
//
// peacemakr-core-crypto
// Copyright (c) 2018 peacemakr
// Full license at peacemakr-core-crypto/LICENSE.txt
//

// ------------------------------------------------------------ //
// ------------- AUTOGENERATED FILE - DO NOT EDIT ------------- //
// -------------  Generated from go/crypto.go.in  ------------- //
// ------------------------------------------------------------ //

package crypto

// #cgo LDFLAGS: -lpeacemakr-core-crypto -L@CORE_LIB_DIR@ -Wl,-rpath @CORE_LIB_DIR@
// #cgo CFLAGS: -I@CORE_LIB_INCLUDE@ -I@OPENSSL_INCLUDE_DIR@
// #include <peacemakr/crypto.h>
// #include <peacemakr/random.h>
// #include <stdlib.h>
// #include <string.h>
/*
   extern int go_rng(unsigned char *, size_t);
   extern char *go_rng_err(int);

   static inline random_device_t cbridge() {
		random_device_t rand = {
			.generator = &go_rng,
			.err = (const char *(*)(int))(&go_rng_err)
		};
		return rand;
   }
*/
import "C"
import (
	"crypto/rand"
	"errors"
	"log"
	"unsafe"
)

//export go_rng
func go_rng(buf *C.uchar, size C.size_t) C.int {
	randomBytes := make([]byte, size)
	_, err := rand.Read(randomBytes)
	if err != nil {
		return 1
	}
	if buf == nil {
		return 2
	}
	if size == 0 {
		return 3
	}
	C.memcpy(unsafe.Pointer(buf), unsafe.Pointer(&randomBytes[0]), size)
	return 0
}

//export go_rng_err
func go_rng_err(err C.int) *C.char {
	switch err {
	case 0:
		return nil
	case 1:
		return C.CString("error ocurred while reading random numbers")
	case 2:
		return C.CString("buf passed in was nil")
	case 3:
		return C.CString("size passed in was zero")
	}
	return nil
}

func NewRandomDevice() RandomDevice {
	return RandomDevice{
		randomDevice: C.cbridge(),
	}
}

type RandomDevice struct {
	randomDevice C.random_device_t
}

type SymmetricCipher int

const (
	AES_128_GCM       SymmetricCipher = 0
	AES_192_GCM       SymmetricCipher = 1
	AES_256_GCM       SymmetricCipher = 2
	CHACHA20_POLY1305 SymmetricCipher = 3
)

type AsymmetricCipher int

const (
	NONE     AsymmetricCipher = 0
	RSA_2048 AsymmetricCipher = 1
	RSA_4096 AsymmetricCipher = 2
	//EC25519       AsymmetricCipher = 3
)

type MessageDigestAlgorithm int

const (
	SHA_224  MessageDigestAlgorithm = 0
	SHA_256  MessageDigestAlgorithm = 1
	SHA_384  MessageDigestAlgorithm = 2
	SHA_512  MessageDigestAlgorithm = 3
	SHA3_224 MessageDigestAlgorithm = 4
	SHA3_256 MessageDigestAlgorithm = 5
	SHA3_384 MessageDigestAlgorithm = 6
	SHA3_512 MessageDigestAlgorithm = 7
)

type EncryptionMode int

const (
	SYMMETRIC  EncryptionMode = 0
	ASYMMETRIC EncryptionMode = 1
)

type CryptoConfig struct {
	Mode             EncryptionMode
	SymmetricCipher  SymmetricCipher
	AsymmetricCipher AsymmetricCipher
	DigestAlgorithm  MessageDigestAlgorithm
}

func configToInternal(config CryptoConfig) C.crypto_config_t {
	return C.crypto_config_t{
		mode:             C.encryption_mode(config.Mode),
		symm_cipher:      C.symmetric_cipher(config.SymmetricCipher),
		asymm_cipher:     C.asymmetric_cipher(config.AsymmetricCipher),
		digest_algorithm: C.message_digest_algorithm(config.DigestAlgorithm),
	}
}

func configFromInternal(config C.crypto_config_t) CryptoConfig {
	return CryptoConfig{
		Mode:             EncryptionMode(config.mode),
		SymmetricCipher:  SymmetricCipher(config.symm_cipher),
		AsymmetricCipher: AsymmetricCipher(config.asymm_cipher),
		DigestAlgorithm:  MessageDigestAlgorithm(config.digest_algorithm),
	}
}

type Plaintext struct {
	Data []byte
	Aad  []byte
}

func plaintextToInternal(plaintext Plaintext) C.plaintext_t {
	return C.plaintext_t{
		data_len: C.size_t(len(plaintext.Data)),
		data:     (*C.uchar)(C.CBytes(plaintext.Data)),
		aad_len:  C.size_t(len(plaintext.Aad)),
		aad:      (*C.uchar)(C.CBytes(plaintext.Aad)),
	}
}

func freeInternalPlaintext(internalPlaintext *C.plaintext_t) {
	if internalPlaintext == nil {
		return
	}

	C.free(unsafe.Pointer(internalPlaintext.data))
	C.free(unsafe.Pointer(internalPlaintext.aad))
}

func serialize(blob *CiphertextBlob) ([]byte, error) {
	var cSize C.size_t
	serialized := C.serialize_blob(blob.blob, (*C.size_t)(unsafe.Pointer(&cSize)))
	if serialized == nil {
		return nil, errors.New("serialization failed")
	}
	return C.GoBytes(unsafe.Pointer(serialized), C.int(cSize)), nil
}

func deserialize(serialized []byte) (*CiphertextBlob, bool) {
	cBlobBytes := C.CBytes(serialized)
	defer C.free(cBlobBytes)
	cBlobLen := C.size_t(len(serialized))
	deserialized := C.deserialize_blob((*C.uint8_t)(cBlobBytes), cBlobLen)
	if deserialized == nil {
		return nil, false
	}
	return &CiphertextBlob{
		blob: deserialized,
	}, true
}

func GetMaxSupportedVersion() uint8 {
	return uint8(C.get_max_version())
}

func PeacemakrInit() bool {
	return bool(C.peacemakr_init())
}

type CiphertextBlob struct {
	blob *C.ciphertext_blob_t
}

type PeacemakrKey struct {
	key *C.peacemakr_key_t
}

func (k *PeacemakrKey) IsValid() bool {
	return k.key != nil
}

func NewPeacemakrKey(config CryptoConfig, rand RandomDevice) PeacemakrKey {
	return PeacemakrKey{
		key: C.PeacemakrKey_new(configToInternal(config), (*C.random_device_t)(unsafe.Pointer(&rand.randomDevice))),
	}
}

func NewPeacemakrKeyFromBytes(config CryptoConfig, contents []byte) PeacemakrKey {
	cBytes := (*C.uint8_t)(C.CBytes(contents))
	defer C.free(unsafe.Pointer(cBytes))
	cNumBytes := (C.size_t)(len(contents))
	return PeacemakrKey{
		key: C.PeacemakrKey_new_bytes(configToInternal(config), cBytes, cNumBytes),
	}
}

func NewPeacemakrKeyFromMasterKey(config CryptoConfig, masterKey PeacemakrKey, keyID []byte) PeacemakrKey {
	cBytes := (*C.uint8_t)(C.CBytes(keyID))
	defer C.free(unsafe.Pointer(cBytes))
	cNumBytes := (C.size_t)(len(keyID))
	return PeacemakrKey{
		key: C.PeacemakrKey_new_from_master(configToInternal(config), masterKey.key, cBytes, cNumBytes),
	}
}

func NewPeacemakrKeyFromPubPem(config CryptoConfig, contents []byte) PeacemakrKey {
	cBytes := (*C.char)(C.CBytes(contents))
	defer C.free(unsafe.Pointer(cBytes))
	return PeacemakrKey{
		key: C.PeacemakrKey_new_pem_pub(configToInternal(config), cBytes, C.size_t(len(contents))),
	}
}

func NewPeacemakrKeyFromPrivPem(config CryptoConfig, contents []byte) PeacemakrKey {
	cBytes := (*C.char)(C.CBytes(contents))
	defer C.free(unsafe.Pointer(cBytes))
	return PeacemakrKey{
		key: C.PeacemakrKey_new_pem_priv(configToInternal(config), cBytes, C.size_t(len(contents))),
	}
}

func GetKeyConfig(key *PeacemakrKey) (CryptoConfig, error) {
	if !key.IsValid() {
		return CryptoConfig{}, errors.New("invalid key passed to GetKeyConfig")
	}
	keyConfig := C.PeacemakrKey_get_config(key.key)
	return configFromInternal(keyConfig), nil
}

func DestroyPeacemakrKey(key PeacemakrKey) error {
	if !key.IsValid() {
		return errors.New("invalid key passed to DestroyPeacemakrKey")
	}
	C.PeacemakrKey_free((*C.peacemakr_key_t)(key.key))
	return nil
}

func Encrypt(key PeacemakrKey, plaintext Plaintext, rand RandomDevice) ([]byte, error) {
	if !key.IsValid() {
		return nil, errors.New("invalid key passed to Encrypt")
	}

	cPlaintext := plaintextToInternal(plaintext)
	defer freeInternalPlaintext(&cPlaintext)

	blob := C.peacemakr_encrypt(key.key, (*C.plaintext_t)(unsafe.Pointer(&cPlaintext)), (*C.random_device_t)(unsafe.Pointer(&rand.randomDevice)))

	if blob == nil {
		return nil, errors.New("encryption failed")
	}

	serialized, err := serialize(&CiphertextBlob{
		blob: blob,
	})

	if err != nil {
		return nil, errors.New("serialization failed")
	}

	return serialized, nil
}

func ExtractCiphertextBlob(ciphertext []byte) (*CiphertextBlob, bool) {
	return deserialize(ciphertext)
}

func ExtractUnverifiedAAD(ciphertext []byte) ([]byte, bool) {
	var plaintext C.plaintext_t
	defer freeInternalPlaintext(&plaintext)
	if ciphertext[len(ciphertext)-1] != 0 {
		ciphertext = append(ciphertext, byte(0)) // add NULL terminator
	}

	deserialized, deserializeSuccess := deserialize(ciphertext)
	if !deserializeSuccess {
		return nil, false
	}

	extractSuccess := bool(C.peacemakr_decrypt(nil, deserialized.blob, (*C.plaintext_t)(unsafe.Pointer(&plaintext))))
	if !extractSuccess {
		return nil, false
	}

	return C.GoBytes(unsafe.Pointer(plaintext.aad), C.int(plaintext.aad_len)), extractSuccess
}

func Decrypt(key PeacemakrKey, ciphertext []byte) (*Plaintext, bool) {
	if !key.IsValid() {
		log.Printf("invalid key passed to Decrypt")
		return nil, false
	}

	var plaintext C.plaintext_t
	defer freeInternalPlaintext(&plaintext)
	if ciphertext[len(ciphertext)-1] != 0 {
		ciphertext = append(ciphertext, byte(0)) // add NULL terminator
	}

	deserialized, success := deserialize(ciphertext)
	if !success {
		return nil, false
	}

	out := C.peacemakr_decrypt(key.key, deserialized.blob, (*C.plaintext_t)(unsafe.Pointer(&plaintext)))

	return &Plaintext{
		Data: C.GoBytes(unsafe.Pointer(plaintext.data), C.int(plaintext.data_len)),
		Aad:  C.GoBytes(unsafe.Pointer(plaintext.aad), C.int(plaintext.aad_len)),
	}, bool(out)
}
